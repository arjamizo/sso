#ifdef fail
        #!/bin/bash
        # NOTE you can chmod 0755 this file and then execute it to compile (or just copy and paste)
        gcc -o hashblock hashblock.c -lssl
        exit 0
#endif

#include <stdio.h>

#include <sys/mman.h>
#include <fcntl.h>
#include <semaphore.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <unistd.h> //required for ftruncate, which is only in gnu99 standard
#include <sys/types.h>
#include <sys/wait.h>
#include <assert.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int max(int a, int b) {
	return a>b?a:b;
}

/**
* function is wrapper for errors
*/
int w(int execcode) {
	if (execcode<0) {
		perror("error somewhere");
	}
	return execcode;
}
/**
* wrapper for errors with line handling
*/
int wl(int execcode, int line) {
	static char msg[200];
	if (execcode<0)
	{
		sprintf(msg, "error somewhere in line %d", line);
		perror(msg);
	}
	return execcode;
}

struct buf_t
{
	int _accA, _accB;
	int wplatyA,wyplatyA;
	int wplatyB,wyplatyB;
} buf;

int kontoA(struct buf_t *rptr, int kwota) {
	int konto=rptr->_accA;
	usleep(50);
	konto+=kwota;
	usleep(50);
	rptr->_accA=konto;
	// rptr->_accA+=kwota;
	if(kwota>0) 
		rptr->wplatyA+=kwota;
	else 
		rptr->wyplatyA+=-kwota;
	return rptr->_accA;
}
int kontoB(struct buf_t *rptr, int kwota) {
	int konto=rptr->_accB;
	usleep(50);
	konto+=kwota;
	usleep(50);
	rptr->_accB=konto;
	// rptr->_accB+=kwota;
	if(kwota>0) 
		rptr->wplatyB+=kwota;
	else 
		rptr->wyplatyB+=-kwota;
	return rptr->_accB;
}


const char BUFNAME[]="/myregion";
int fd;
int tmpIdToClose=-1;
void exiting()
{
	wl(close(fd),__LINE__);
	// int ret=

	shm_unlink(BUFNAME);
	// wl(ret,__LINE__);
	// if(tmpIdToClose>-1) {
	// 	char fnm[20];
	// 	snprintf(fnm, sizeof fnm, "/tmp/TMPBUFF_%d.txt", tmpIdToClose);
	// 	fprintf(stderr, "Closing %s.\n", fnm);
	// 	wl(unlink(fnm),__LINE__);
	// }

}

#define KEY ((key_t) 123456L) //could be generated by semkey
#define PERM 0600
int semid;
int semInit(int cnt) {
	int semtoken=wl(ftok("/dev/null",KEY),__LINE__);
	semid=wl(semget(semtoken, cnt, 0666 | IPC_CREAT),__LINE__);
	short initarray[cnt];
	for (int i = 0; i < 2; ++i) initarray[i]=1;
		//semafory ustawiane na 0 dlatego, ze przyjmuje konwencje, 
		//po przeczytaniu dokumentacji man semop, ze inne procesy beda czekac az wartosc 
		//semafory bedzie 0

	for (int i = 2; i < cnt; ++i) initarray[i]=0;
		//ale ostatnie semafory beda domyslnie 

	assert(initarray[0]==1);
	assert(initarray[cnt-1]==0);
	wl(semctl(semid, cnt, SETALL, initarray),__LINE__);
	return semid; 
}

void semTake() {
	struct sembuf sops;
	sops.sem_num = 0;
	sops.sem_op = -1;
	sops.sem_flg = 0;
	wl(semop(semid, &sops, 1),__LINE__);
}

void semRelease() {
	struct sembuf sops;
	sops.sem_num = 0;
	sops.sem_op = 1;
	sops.sem_flg = 0;
	wl(semop(semid, &sops, 1),__LINE__);
}

int semFree(int cnt) {
	return wl(semctl(semid, cnt, IPC_RMID),__LINE__);
}

void transaction(int *from, int *to, int seed) {
	#define LEN 4
	static int amounts[5]={90,80,100,100,200};
	int *froms[4]={(int*)0,(int*)0, from, from};
	char fromsChr[LEN]={'n', 'n','A','A'};
	char tosChr[LEN]={'B','A','B','n'};
	int *tos[4]={to, from, to, (int*)0};
	int already=seed;
	int amount=amounts[already%(sizeof amounts/sizeof *amounts)];
	from=froms[already%LEN];
	to=tos[already%LEN];//This lottery system allows creating almost "random" transaction processes :D 
	int waswaiting=0;
	fprintf(stderr, "Trying %c->%c amount %d\n", from?fromsChr[already%LEN]:' ', to?tosChr[already%LEN]:' ', amount);
	while(1) {
		// if((from && *from<amount)) fprintf(stderr, "Waiting for acc%c, cos want to do: ", fromsChr[already%3]);

		if (from && *from<amount) { //umieszczenie warunku sprawdzajacego tak daleko od warunku 
			// sleep(1);

			waswaiting++; 
			continue;
		}
		fprintf(stderr,"run trans ");
		if(!from && to) fprintf(stderr,"->%c(%d PLN)", tosChr[already%LEN], *to);
		else if(from && !to) fprintf(stderr,"%c(%d PLN)->", fromsChr[already%LEN], *from);
		else fprintf(stderr,"%c(%d PLN)->%c(%d PLN)", fromsChr[already%LEN], *from, tosChr[already%LEN], *to);
		fprintf(stderr," for %d, was waiting for %d \n", amount, waswaiting);


		if(from==NULL) sleep(1); //tylko procesy przelewajace pieniadze badz wyplacajace beda czekac
		assert(!(from && *from<amount));
		if(from!=NULL) *from-=amount; //WANZE: to, ze jest taki duzy odstep czasu pomiedzy sprawdzeniem a przelewem umozliwia pokazanie wyscigu, w tym momencie wykonywania kodu warunek, ze jest na koncie odpowiednia ilosc pieniedzy powinien byc zawsze prawdziwy
		if(to!=NULL) *to+=amount;
		// fprintf(stderr, "Sleeping for %d\n", already%10+1);

		waswaiting=0;
		// sleep(already%10+1);
		// sleep(1);

	}
	#undef LEN
}
int useSemaphores=0;
int main(int argc, char const *argv[])
{
	if(argc>1 && strcmp("--sems",argv[1])==0)
		useSemaphores=1;
	atexit(exiting);
	// wl(

	shm_unlink(BUFNAME)
	// ,__LINE__)

	;
	fd = wl(shm_open(BUFNAME, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR /*0774?*/),__LINE__);
	// fd = shm_open("/myregion", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);

	w(fd);
	size_t size = wl(ftruncate(fd, sizeof(buf)),__LINE__);
	fprintf(stderr, "truncated %zu\n", size); //%zu stands for size_t

	struct buf_t *rptr;
	rptr = (struct buf_t*)mmap(NULL, sizeof(buf),
		   PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (rptr == MAP_FAILED) w(-1);


	semInit(3);
	int processCount=4;
	for (int i = 0; i < processCount; ++i)
	{
		int r=fork();
		if(r==0) { //child
			fprintf(stderr, "\t\t%s\n", "Child");
			char buf[50];
			// atexit(exiting);

			snprintf(buf, sizeof buf, "/tmp/TMPBUFF_%d.txt", i);
			int fd=open(buf, O_RDWR | O_CREAT | O_TRUNC); //BRAK EFEKTYWNEJ METODY ZAMYKANIA CLOSEM! TODO
			char cmd[200];
			dup2(fd, STDOUT_FILENO);
			dup2(fd, STDERR_FILENO);
			snprintf(cmd, sizeof cmd, "xterm -hold -e 'chmod 777 %s ; ls -l %s ; tail -f %s' &", buf, buf, buf);
			fprintf(stderr, "system(%s)=%d\n", cmd, system(cmd));
			// sleep(3);
			// transaction(&rptr->accA,&rptr->accB, i);

			/*

			Wyciagniete z man semop: jesli argumentem semop jest -1, to proces
			zatrzymuje sie na czas, az inny wykona semop z argumentem +1

				Pierwsza semafora [id=0]: 
					1 - konto A jest modyfikowane
					0 - konto A nie jest przez nikogo modyfikowane
				Druga semafora [id=1]: 
					1 - konto B jest modyfikowane
					0 - konto B nie jest przez nikogo modyfikowane
				Trzecia semafora [id=2]: 
				   -1 - ostatnia ilosc pieniedzy na koncie B nie byla
						wystarczajaca,  aby wykonac transakcje trzeba czekac
						az bedzie rowna 0
						TAK NAPRAWDE proba zmiany semval o -1
						(oczekiwanie az inny proces wpisze doń +1) 
					0 - tylko na te wartosc mozemy czekac zgodnie ze specyfikacja man semop;
						zaktualizowano ilosc pieniedzy na koncie B 

			*/
				#define SEM_KONTOA 0
				#define NIKT_INNY_NIE_MOZE_WEJSC -1
				#define INNI_MOGA_WCHODZIC 1
				#define SEM_KONTOB 1
				struct sembuf zajmijA={SEM_KONTOA, NIKT_INNY_NIE_MOZE_WEJSC, 0};
				struct sembuf zwolnijA={SEM_KONTOA, INNI_MOGA_WCHODZIC, 0};
				struct sembuf zajmijB={SEM_KONTOB, NIKT_INNY_NIE_MOZE_WEJSC, 0};
				struct sembuf zwolnijB={SEM_KONTOB, INNI_MOGA_WCHODZIC, 0};
			if(i==0) {
				//A: proces wplacajacy pieniadze na konto A
				//B: zalozenia: tylko zapisywanie do konta A (mutex do zmiany wartosci tego konta)
				//C: skutki: podniesienie semafory informujacej o pieniadzach na koncie

				while(1) {
					fprintf(stderr, "przed zajeciem konta A\n");
					wl(semop(semid, &zajmijA, 1),__LINE__);
					
					kontoA(rptr, 10);
					fprintf(stderr, "A: %d+%d=%d\n", rptr->_accA-10,10,rptr->_accA);
					
					wl(semop(semid, &zwolnijA, 1),__LINE__);
					//sleep(10);
					char a=getchar();
					fprintf(stderr, "a=%c\n", a);
					if(a=='r' || a=='q') {
						fprintf(stderr, "Raport z dzialania systemu: \nNa koncie A jest %d, w sumie wplatono don %d i wyplacono %d, powinno na nim byc %d (blad %d) \nNa koncie B jest %d, w sumie wplatono don %d i wyplacono %d, powinno na nim byc %d (blad %d)\n"
						, rptr->_accA, rptr->wplatyA, rptr->wyplatyA, rptr->wplatyA-rptr->wyplatyA, rptr->_accA-(rptr->wplatyA-rptr->wyplatyA)
						, rptr->_accB, rptr->wplatyB, rptr->wyplatyB, rptr->wplatyB-rptr->wyplatyB, rptr->_accB-(rptr->wplatyB-rptr->wyplatyB)
						);
					}
				}
			} else if (i==1) {
				//A: proces wyplacajacy z konta B
				//B: zal: adekwatne do zalozen w przypadku i==0
				//C: skutki: podobne

				while(1) {
					fprintf(stderr, "Przed zajeciem B\n");
					wl(semop(semid, &zajmijB, 1),__LINE__);
					fprintf(stderr, "Zajete B\n");
					if(rptr->_accB>=10) {
						fprintf(stderr, "B: %d-%d=%d\n", rptr->_accB,10,rptr->_accB-10);
						kontoB(rptr,-10);
						fprintf(stderr, "Zwolnione B\n");
						wl(semop(semid, &zwolnijB, 1),__LINE__);
					}
					else {
						// union semun {
						// 	//Unia dlatego, ze potrzebne była struktura 
						// 	//umożliwiająca przekazanie różnych danych 
						// 	int val;                /* wartość dla SETVAL */
						// 	struct semid_ds *buf;   /* bufor dla IPC_STAT i IPC_SET */
						// 	ushort *array;          /* tablica dla GETALL i SETALL */
						// 	struct seminfo *__buf;  /* bufor dla IPC_INFO */
						// 	void *__pad;
						// } arg0;

						int val=0;
						
						//POMYSL NA DODANIE ELASTYCZNEJ IMPLEMENTACJI:
						//dodatkowy semafor, ktory przechowuje ile procesow
						//chce pobierac pieniadze z tego konta

						// fprintf(stderr, "wartosc sem=%d winno byc 1\n", semctl(semid, 2, GETVAL, 0));
						semctl(semid, 2, SETVAL, val); //to trick, dziala dlatego, ze argumentem jest unia.
						// POLECAM! http://www.linuxpl.org/LPG/node52.html
						// fprintf(stderr, "wartosc sem=%d winno byc 0\n", semctl(semid, 2, GETVAL, 0));


						fprintf(stderr, "Zwolnione B\n");
						wl(semop(semid, &zwolnijB, 1),__LINE__);

						if(useSemaphores) fprintf(stderr, "Na koncie B brak pieniedzy. CZEKAJ.\n");
						struct sembuf czekaj_az_kasa={2, -1, 0};
						#define wait() semop(semid, &czekaj_az_kasa, 1) 
						if(useSemaphores) wait(); //notify wybudza tego waita
						//ze wczesniej wpisano wartosc 0 do semafora, bedzie on czekal
						//az inny proces zglosi, ze wplacono pieniadze na konto A

						#undef wait
					}
					sleep(1);//sleep sekunde po tym, jak zostal wybudzony - asynchronicznosc! 
					
				}
			} else if(i>=2) {
				//proces przelewajacy pieniadze z konta A na konto B
				//zalozenia: 1) na koncie A musza byc pieniadze (w przypadku braku pieniedzy 
				//oczekiwanie na 2) podniesienie semafory o obecnosci 
				//pieniedzy na koncie); 3) zablokowanie obu kont; 4) przelanie pieniedzy; 
				// 4) zwolnienie blokady kont


				//poki co trywialna implementacja przelwow

				if(!useSemaphores) {
					while(1) {
						int kwota=max(10,rptr->_accA/10);
						if(rptr->_accA>=kwota) {
							kontoA(rptr, -kwota);
							kontoB(rptr, kwota);
							fprintf(stderr, "Przelew z kontaA na kontoB na %d PLN.\n", kwota);
						}
					}
				} 
				else if (useSemaphores) {
					struct sembuf obaKontaNaWylacznosc[2]={
						{0,-1,0},{1,-1,0} //pytanie brzmi czy to zawsze da sie wykonac razem? w razie czego IPC_NOWAIT
					};
					struct sembuf zwolnijObaKonta[2]={
						{0,1,0},{1,1,0}
					};
					while(1) {
						wl(semop(semid, obaKontaNaWylacznosc, 2),__LINE__);
						// fprintf(stderr, "Oba na wylaczonosc\n");
						int kwota=max(10,rptr->_accA/2);
						if(rptr->_accA>=kwota) {
							// sleep(1);
							// sleep(1);
							kontoA(rptr,-kwota);
							kontoB(rptr,kwota);
							sleep(1);
							fprintf(stderr, "Przelew z kontaA na kontoB na %d PLN.\n", kwota);

							#ifdef ZYJEMY_W_RZECZYWISTOSCI_W_KTOREJ_semctl_SETVAL_BUDZI_SPIACE_PROCESY
								semctl(semid, 2, SETVAL, 1); 
								//wazne jest, aby ustawic wartosc dodania na semaforze
								//informujacej o pojawieniu sie pieniedzy na koncie
								//tak, aby proces oczekujacy na te informacje mogl
								//zmniejszyc wartosc tej semafory
							#else
								struct sembuf kasa_zmieniona={2, +1, 0};
								#define notify() semop(semid, &kasa_zmieniona, 1) 
								notify(); 
								#undef notify
							#endif
						}
						// fprintf(stderr, "koniec wylaczonosci\n");
						wl(semop(semid, zwolnijObaKonta, 2),__LINE__);
						sleep(1);
						//Pragne zauwazyc, ze proces wyplacajacy pieniadze z konta
						//B czeka sekunde dluzej, dzieki temu mozna zauwazyc cudowna transakcje

					}
				}
			}
		} else if (r>0) { //parent
			fprintf(stderr, "\t%s\n", "Parent");
		} else
			wl(r,__LINE__);
	}
	for (int i = 0; i < processCount; ++i)
	{
		int status;
		wait(&status);
	}
	wl(semFree(3),__LINE__);

	return 0;
}